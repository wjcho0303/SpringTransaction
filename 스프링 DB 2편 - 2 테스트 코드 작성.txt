- 테스트를 DB에 연동하기
@SpringBootTest 어노테이션이 붙어 있으면 @SpringBootApplication 애너테이션의 위치를 탐색하여 거기에 있는 설정들을 사용하게 된다.
@SpringBootApplication 애너테이션은 바로 main 패키지의 실행 파일에 존재한다.

    @Import(JdbcTemplateV3Config.class)
    @SpringBootApplication(scanBasePackages = "hello.itemservice.web")
    public class ItemServiceApplication {
        ... 
    }

그러므로 테스트 코드는 이 설정들을 따르게 된다: 
    @Import(JdbcTemplateV3Config.class)
    @SpringBootApplication(scanBasePackages = "hello.itemservice.web")

이 상태에서 테스트를 한 번 돌려보면 어떻게 될까?
결론부터 말하자면 문제가 생긴다. 테스트 메서드의 로직에는 문제가 없다. 
왜냐하면 테스트 로직은 DB에 데이터가 없다고 가정하고 작성한 로직들이기 때문이다.
그러므로 테스트 메서드의 로직을 바꾸는 게 아니라, local 프로필의 DB가 테스트에 영향을 주지 않게 해야 하는 방향으로 해결해야 한다.
그리고, local 환경의 데이터를 없애는 방향으로 해결하는 것도 잘못된 방법이다.
테스트는 '격리성'이 중요하기 때문에 local 환경의 데이터와 test 환경의 데이터는 분리되어야 한다.



- 테스트를 local 용 DB와 분리시키기: "테스트는 다른 테스트와 격리해야 한다"
local의 DB와 테스트의 DB를 공유하면 문제가 발생할 수밖에 없다.
가장 간단한 해결책은 테스트 전용 DB를 별도로 운영하면 된다.

현재 test/resources/application.properties 에는 다음과 같은 내용이 있다:
    spring.datasource.url=jdbc:h2:tcp://localhost/~/test

이는 main에서 사용하는 설정 파일 내용들을 그대로 복붙해왔기 때문에 이렇게 되어 있는데, 이것을 다음과 같이 바꾼다:
    spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase

이제 작업표시줄에 H2 아이콘을 우클릭하여 Exit 하여 H2 서버를 종료하고 다시 실행한다.
그리고 JDBC URL에 jdbc:h2:~/testcase, 사용자명에 sa를 최초 한 번 입력하여 mv.db 파일 생성을 확인한 후
jdbc:h2:tcp://localhost/~/testcase 이렇게 접속한다.

그렇게 한 후 테스트 H2 서버에서도 똑같이 ddl 정보가 담긴 sql/schema.sql 파일의 create table 쿼리를 날린다
    drop table if exists item CASCADE;
    create table item
    (
        id        bigint generated by default as identity,
        item_name varchar(10),
        price     integer,
        quantity  integer,
        primary key (id)
    );



- "테스트는 반복 실행이 가능해야 한다"
이제 findItems() 테스트를 실행하면 성공적으로 테스트를 한다. 하지만 한 번 더 테스트를 누르면 실패한다.
그 이유는 테스트를 하면서 저장한 데이터를 삭제하게 하는 설정이 H2 DB에 맞지 않기 때문이다:

    @AfterEach
    void afterEach() {
        //MemoryItemRepository 의 경우 제한적으로 사용
        if (itemRepository instanceof MemoryItemRepository) {
            ((MemoryItemRepository) itemRepository).clearStore();
        }
    }

이 방식은 메모리 방식으로 진행할 때나 유효한 방식이기 때문에 H2 DB 환경에서는 테스트를 반복 실행할 수가 없다.

그렇다면 테스트가 끝날 때마다 delete 쿼리를 날려서 없애는 방법이 좋을까?
일반적으로는 이 방법도 나쁘지 않다. 하지만 완벽하지는 않다. 그 이유는 테스트 실행 도중에 예외가 터져서 테스트가 중단되거나,
예기치 못한 상황에 의해 애플리케이션이 종료되면 delete 쿼리를 날리지 못하는 일이 발생할 수도 있기 때문이다. 

더 좋은 방법은 바로 트랜잭션을 도입하여 테스트가 끝나는 시점에 커밋을 하지 않고 롤백을 시키는 것이다.
그리고 트랜잭션을 도입하면 꼭 롤백을 시키지 않더라도 테스트 중간에 테스트가 중단되어도 어차피 커밋이 되지 않아
롤백을 한 것과 같은 효과가 있다.



- 테스트에 트랜잭션 도입하기

    @Autowired
    PlatformTransactionManager transactionManager;

    TransactionStatus status;

    @BeforeEach
    void beforeEach() {
        // 트랜잭션 시작
        status = transactionManager.getTransaction(new DefaultTransactionDefinition());
    }

    @AfterEach
    void afterEach() {
        //MemoryItemRepository 의 경우 제한적으로 사용
        if (itemRepository instanceof MemoryItemRepository) {
            ((MemoryItemRepository) itemRepository).clearStore();
        }

        // 트랜잭션 롤백
        transactionManager.rollback(status);
    }

트랜잭션 관리자는 PlatformTransactionManager를 주입 받아서 사용하면 된다.

    * 참고
    스프링 부트는 자동으로 적절한 트랜잭션 관리자를 스프링 빈으로 등록해준다.

이렇게 되면 테스트를 시작할 때 트랜잭션을 시작하게 하고, 테스트가 마무리되면 트랜잭션을 종료시킬 수 있다.
이제 다시 H2에서 delete from item을 한 후 테스트를 모두 돌려보면 정상적으로 작동함을 확인할 수 있다.
로그에도 아래와 같은 로그가 출력된다.
    o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [null]: ... 
        ...
    o.s.jdbc.support.JdbcTransactionManager  : Rolling back JDBC transaction on Connection 

그 대신에 이제 모든 테스트에서 rollback을 하기 때문에 H2를 통해 남아 있는 데이터를 볼 수 없다.

    * 참고
    JdbcTemplate은 친절하게도 트랜잭션 동기화 매니저에 있는 Connection을 가져다 쓰도록 설계되어 있다.
    그렇기 때문에 한 트랜잭션 내에서는 동일한 Connection을 가져다 쓰도록 설계되어 있다.



- 테스트에서의 @Transactional 어노테이션
이제 트랜잭션은 성공적으로 도입되었고, 테스트도 정상적으로 격리 및 재실행이 되었다. 
그러나 스프링은 여기서 그치지 않고 더욱더 편리한 기능을 제공한다. 바로 @Transactional 이다.

@Transactional의 원래 기능은 로직이 성공적으로 수행되면 commit을 하는 것이다. 즉 테스트가 아닐 때는 commit을 한다.
하지만 놀라운 점은 테스트 환경에서 @Transactional을 사용하면 commit이 아닌 rollback을 하도록
스프링에서 알아서 설계를 해놓았다는 것이다.

트랜잭션 도입할 때 PlatformTransactionManager 필드 주입 받고, TransactionStatus 필드 선언하고,
@BeforeEach에서는 transactionManager.getTransaction(new DefaultTransactionDefinition()); 코드를 통해 트랜잭션을 시작하고,
@AfterEach에서는 transactionManager.rollback(status); 을 통해 트랜잭션을 롤백하는 등 일련의 트랜잭션을 도입하기 위한 과정이 필요했다.

하지만 @Transactional 애너테이션 하나만 있으면 위에 나열한 작업들이 자동으로 수행된다.
위에 나열한 작업 코드들을 모두 지워버리고 테스트 클래스명 앞에 @Transactional만 딸깍 달아주면 된다.

    @SpringBootTest
    @Transactional
    class ItemRepositoryTest {
        ...
    }

단, @Transactional을 import할 때는 org.springframework의 것을 가져와야 한다:
    import org.springframework.transaction.annotation.Transactional;


* 참고
그러면 만약, @Transactional이 걸린 Service의 코드를 테스트할 때 @Transactional을 달면 어떻게 될까?
Service의 @Transactional은 commit을 하는 것인데, 테스트의 @Transactional은 rollback을 하는 것이니 말이다.
결론부터 말하자면 이런 경우에는 테스트의 트랜잭션을 따라 rollback이 된다. 이에 대해서는 후에 더 자세히 다룰 것이다.


*참고: 테스트 + @Transactional 환경에서 강제로 commit 하기 
테스트를 하다 보면 저장된 데이터를 잠깐 보고 싶을 수 있다. 그럴 때는 rollback 말고 commit을 해야 한다.
테스트 환경에서 commit 하기 원하는 메서드 앞에는 @Commit 또는 @Rollback(false) 둘 중 하나를 달아주면 된다.



- H2 임베디드 모드 DB란?
테스트 케이스를 실행하기 위해서 별도의 DB를 설치하고 운영하는 것은 상당히 번잡하다.
단순히 테스트를 검증할 용도로만 사용하기 때문에 테스트가 끝나면 DB의 모든 데이터가 삭제되어도 무방하다. 
더 나아가, 테스트가 끝나면 DB 자체를 제거해도 무방하다.

H2 DB는 자바로 개발되어 있고, JVM 안에서 메모리 모드로 동작하게 하는 특별한 기능을 제공한다.
그래서 H2 DB를 별도로 설치하지 않아도 애플리케이션을 실행할 때 H2 DB도 해당 JVM 메모리에 포함해서 함께 실행시킬 수 있다. 
이런 경우 DB를 애플리케이션에 내장시켜 함께 실행하기 때문에 Embedded Mode 라고 부른다.
물론 이렇게 하면 애플리케이션을 종료하면 H2 DB도 함께 종료되고, 데이터들도 모두 사라진다.



- 임베디드 모드 사용하기
앱 실행 클래스 ItemServiceApplication 내부에 아래와 같은 내용을 추가한다: 

// 테스트를 수행하기 위해 프로필이 test인 경우에만 주입할 DataSource를 빈으로 등록
    @Bean
    @Profile("test")
    public DataSource dataSource() {
        log.info("메모리 데이터베이스 초기화");
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("org.h2.Driver");
        dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");
        dataSource.setUsername("sa");
        dataSource.setPassword("");
        return dataSource;
    }

이 코드를 추가하면 H2를 설치하지 않고도 메모리에서 사용할 수 있다. 
* 프로필이 test인 경우에만 DataSource를 빈으로 등록한다. 즉, 테스트 케이스에서만 이 DataSource를 스프링 빈으로 등록하겠다는 것이다.
* jdbc:h2:mem:db : 이렇게 적으면 임베디드 모드, 즉 메모리 모드로 동작하는 H2 DB를 사용할 수 있다.
* DB_CLOSE_DELAY=-1 : 임베디드 모드에서는 DB Connection 연결이 모두 끊어지면 DB도 종료되는데, 그것을 방지하기 위한 설정이다.

그런데, 메모리 DB를 사용하면 애플리케이션 실행 시점에 DB 테이블이 없는 상태이다.
스프링 부트에서는 임베디드 모드 사용을 지원하기 위해 기본 SQL 스크립트를 사용하여 DB를 초기화하는 기능을 제공한다.
물론 JDBC나 JdbcTemplate을 통해 직접 테이블을 생성하는 DDL을 호출해도 되지만 이 방법은 너무 불편하다.
그렇기 때문에 스프링 부트에서는 스크립트를 실행해서 애플리케이션 로딩 시점에 DB를 초기화하는 기능을 제공한다.

그렇다면 그 기본 SQL 스크립트는 어떻게 만들면 되나?
src/test/resources 디렉토리 위치에 다음과 같은 내용의 schema.sql 파일을 생성한다:
    drop table if exists item CASCADE;
    create table item
    (
        id        bigint generated by default as identity,
        item_name varchar(10),
        price     integer,
        quantity  integer,
        primary key (id)
    );
사실 drop에 관한 코드는 없어도 되는데 그냥 넣어둔다.
이렇게 해두면 테스트를 임베디드 모드 DB를 사용하면서 실행할 때 이 src/test/resources/schema.sql 이 먼저 작동한다.
그리고 테스트도 정상 동작하게 된다.



- 스프링 부트로 임베디드 모드 더 간편하게 설정하기
임베디드 모드를 활용하여 테스트를 수행하는 개발자가 굉장히 많기 때문에,
스프링 부트는 임베디드 모드를 통해 테스트를 수행할 수 있는 더 간편한 방법을 제공한다.

1) 위에서 ItemServiceApplication에 작성해준 DataSource 주입 부분을 지워버린다:
    @Bean
    @Profile("test")
    public DataSource dataSource() {
        log.info("메모리 데이터베이스 초기화");
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("org.h2.Driver");
        dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");
        dataSource.setUsername("sa");
        dataSource.setPassword("");
        return dataSource;
    }
이 코드를 지운다.

2) src/test/resources/application.properties 에서 H2 DB에 접근하는 정보와 관련된 코드를 지운다.
(src/main 에 있는 것을 건드리지 말 것!)

    spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase
    spring.datasource.username=sa
    spring.datasource.password=
이 코드를 지운다.

끝.

위와 같이 별다른 정보를 아예 제공하지 않으면 스프링 부트가 알아서 임베디드 모드로 접근하는 DataSource를 만들어서 제공한다.
실제로 ItemRepositoryTest 테스트를 반복 실행해도 잘 작동함을 확인할 수 있다.

로그를 보면 
Acquired Connection [HikariProxyConnection@2129554451 wrapping conn0: url=jdbc:h2:mem:c497587e-91a6-4246-be64-2475d6426736 user=SA] for JDBC transaction

이런 내용을 볼 수 있다. jdbc:h2:mem 뒤에 있는 임의의 문자열은 혹시라도 여러 DataSource가 사용될 때
같은 DB를 사용하면서 발생하는 충돌을 방지하기 위해 스프링 부트가 임의로 부여한 것이다.

만약 이 임베디드 DB의 이름을 스프링 부트가 기본으로 제공하는 jdbc:h2:mem:testdb로 고정하고 싶으면
src/test/resources/application.properties에 아래의 내용을 추가한다:
    spring.datasource.generate-unique-name=false
다만, 이 설정을 사용하는 것보다 스프링 부트가 임의로 생성해주는 이름을 그냥 사용하는 게 더 낫다.



- 테스트 코드 작성 파트 최종 결론
테스트에 @Transactional 이거 하나 넣어주면 된다...★
하지만 이러한 것들을 모두 이해하면 분명히 도움이 될 것이다.

